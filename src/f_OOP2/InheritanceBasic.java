package f_OOP2;

public class InheritanceBasic {
	public static void main(String[] args) {
		/*
		 1.상속(~은 ~이다.)
		 	- 기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
		 	- 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		 	- 새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을 키워드
		 		'extends'와 함께 써주기만 하면 된다.
		 		
		 		class Child extends Parent{}
		 		
		 	- 상속을 해주는 클래스를 '조상클래스', 상속받는 클래스를 '자손클래스'라고 한다.
		 		: 조상클래스 = 부모클래스, 상위클래스, 기반클래스
		 		: 자손크래스 = 자식클래스, 하위클래스, 파생된 클래스
		 	- 멤버만 상속된다.(멤버변수와 메서드만 상속)
		 	- 자손클래스의 멤버의 개수는 부모클래스 보다 같거나 많다.
		 	
		 
		 2. 포함(~은 ~을 포함하고 있다.)
		 	- 상속 이외에 클래스를 재사용하는 또다른 방법
		 	- 한 클래스의 멤버변수로 다른 클래스를 선언하는 방식
		 	
		 3. 단일상속
		 	- 자바에서는 단일상속(2개 이상은 불가능)만 가능하다.
		 	- class TVCR extends Tv,VCR{	//VCR은 동시에 쓸 수 없다.
		 	
		 	}
		 	- Tv와 VCR에 동일한 메서드가 존재한다면 어떤 메서드를 상속받을지 알 수 없다.
		 	- VCR의 메서드 명을 바꾼다면---> 다중상속은 가능해지겠지만,
		 		지금까지 VCR의 메서드를 사용한 부분들을 모두 바꿔 주어야 한다.
		
		 4. Object클래스(모든 클래스의 조상)
		 	- 모든 클래스 상속 계층도의 제일 위에 위치하는 조상 클래스 이다.
		 	- 다른 클래스로 부터 상속을 받지 않는 모든 클래스는 Object클래스를 자동적으로 상속받게 된다.
		 	
		 	//컴파일 전
		 	class Tv{
		 	
		 	}
		 	
		 	//컴파일 후
		 	: class Tv extends Object{
		 			Tv(){
		 				super();
		 			}
		 		}
		 	- 모든 클래스는 Object클래스를 상속 받는다.
		 	- equals(). toString()같은 메서드를 따로 정의하지 않고 사용하는 것은
		 		Object클래스를 상속 받기 때문이다.
		 		
		 5. toString()
		 	- 인스턴스의 정보를 문자열로 반환할 목적으로 정의되었다. 
		 	- system.out.println(c)
		 					----->system.out.println(c.toString)   (참조형변수.toString)이 포함되어있다.
		 
		 6. 오버라이드(Override)
		 	- 조상클래스로 부터 상속받은 메서드의 내용을 변경(재정의)하는 것
		 	- 오버라이드가 되기 위한 조건
		 		: 	자손클래스에서 오버라이드하는 메서드는 조상 클래스의 메서드와
		 			이름은 같아야 한다.									
		 			매개변수의 갯수는 같아야 한다.
		 			매개변수의 타입은 같아야 한다.
		 			반환타입은 같아야 한다.
		 					=> 선언부가 같아야 한다. 
		 		: 접근제어자는 조상클래스보다 넓은 범위로 변경할 수 없다.
		 		: 예외는 부모클래스의 메서드보다 많이 선언할 수 없다.
		 		: 인스턴스 메서드를 클래스메서드로 변경할 수 없다.
		 		
		 7. super
		 	- 조상클래스의 멤버와 자손클래스의 멤버가 중복정의되어 있을 때 구분할 용도로 만들어 준다.
		 	- this.과 근본적으로 같다. 조상의 멤버와 자식의 멤버를 구분한다. 
		 	- static멤버에는 사용할 수 없다.(인스턴스멤버 간에만 사용가능)		--> this. : 인스턴스변수와 지역변수의 이름이 같을 때 구분 용도
		 	
		 	
		 8. super()
		 	- this() : 생성자 안에서 다른 생성자를 호출----> 생성자의 가장 첫줄에 적어야 한다.
		 	- this()와 마찬가지로 생성자 호출
		 	- this()는 같은 클래스의 다른 생성자를 호출
		      super()조상클래스의 생성자를 호출
		 	- 생성자의 첫줄에서는 항상 조상클래스의 생성자를 호출해야 한다.
		 	- 모든 생성자의 첫줄에 super()가 숨어있다.
		 	
		 9. 제어자
		 	- 클래스, 변수 또는 메서드에 선언부에 사용한다.
		 	- 접근제어자, 그 외 제어자로 구분
		 	- 접근제어자 : public, protected, default, private
		 	    그외 제어자 : static, final, abstract, native.........
		 	- static(클래스의, 공통적인)
		 		 : 멤버변수, 메서드, 초기화 블럭에 사용가능
		 		 : static 변수
		 		 	--> 모든 인스턴스에서 공통적으로 사용된다.
		 		 	--> 인스턴스를 생성하지 않고 호출 가능(클래스명.변수명)
		 		 	--> 클래스가 메모리에 로드될 때 같이 생성된다.
		 	- final(마지막의, 변경할 수 없는
		 		: 클래스, 변수, 메서드 사용 가능
		 		: 변수에 사용 시 상수가 된다.
		 		: 메서드에 사용 시 오버라이드가 불가능한 메서드가 된다. 
		 		: 클래스에 사용 시 확장할 수 없는 클래스 즉, 상속이 불가능한 클래스가 된다.
		 	- abstract(추상의, 미완성의)	
		 		: 클래스, 메서드에 사용가능
		 		
		 		
		 10. 접근제어자 		
		 	- public	: 접근제한이 없다. 
		 	- protected	: 같은패키지 + 다른 패키지의 자손 클래스
		 	- default	: 같은 패키지 내에서 호출가능
		 	- private	: 같은 클래스 내에서만 호출가능
		 	- 클래스 : public, default만 클래스 앞에서 사용가능
		 	- 변수와 메서드에는 전부 사용이 가능
		 	
		 11. 생성자의 접근제어자
		 	- 인스턴스의 생성을 제한할 수 있다.
		 	- 생성자의 접근제어자를 private으로 지정
		 		: 외부에서 생성자에 접근할 수 없으므로 인스턴스를 생성할 수 없다.
		 		: 다른 클래스의 조상이 될 수 없다.
		 		: 조상이 될 수 없는 클래스 임으로 final을 추가하여 상속할 수 없는 클래스임을 알려주는 것이 좋다.
		 
		 12. 다형성(polymorphism)
		 	- 여러가지 형태를 가질 수 있는 능력
		 	- 한 타입의 참조변수로 여러타입의 인스턴스를 참조할 수 있다.
		 	- 부모타입의 참조변수로 자식타입의 인스턴스를 참조할 수 있다.
		 	※ 데이터관리에 수월
		 	
		 13. 참조변수의 형변환
		 	- 서로 상속관계에 있는 클래스에서만 형변환이 가능하다.
		 	- 자손타입->조상타입(up-casting) : 형변환 생략 가능
		 	- 조상타입->자손타입(down-casting) : 형변환 생략 불가
		 	
		 14. instanceof연산자
		 	- 참조하고 있는 인스턴스의 실제타입을 알아보기 위해 사용
		 	- 연산결과가 true라면 참조변수가 검사한 타입으로 형변환이 가능하다.
		 	- 클래스메서드 클래스변스처럼 참조변수의 타입에 영향을 받는다.
		 	- 참조변수의 타입에 영향을 받지 않는 것은 인스턴스메서드 뿐이다. 
		 	
		 15. 매개변수의 다형성
		 	- 참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.
		 	
		 
		 16. 여러객체배열, Vector
		 	- 배열을 사용할 경우 전체 크기를 한 번 정하면 확장할 수 없다.
		 	- 동적으로 관리되는 객체배열이라고 생각하면 된다.
		 	
		 	Vector()	: 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다.
		 	add()		: Vector에 객체를 추가할 때 사용한다. 
		 	remove()	: Vector에서 객체를 제거한다.
		 	isEmpty()	: Vector가 비어있는지 검사한다.
		 	get(int index) : index번째 객체를 반환한다.
		 	int size()	: 저장된 객체의 갯수를 반환 
		 	
		 17. 추상클래스(abstract class)
		 	- 미완성된 클래스 : 미완성된 메서드를 포함하고 있다.
		 	
		 		abstract class 클래스명{
		 	
		 		}
		 	- 추상메서드
		 		: 메서드는 선언부와 구현부로 구성되어 있다.
		 		: 선언부만 작성되고 구현부는 작성되지 않은 메서드
		 		abstract 반환타입 메서드명(변수타입 변수명,....);
		 		
		 18. 인터페이스
		 	- 일종의 추상클래스이지만 추상메서드와 상수만을 멤버로 가진다.
		 	- 인터페이스의 작성
		 		interface 인터페이스명{
		 			(public static final) 변수타입 변수명 = 값;	(상수형태)
		 			(public abstract) 반환타입 메서드명(변수타입 변수명,...);
		 		}
		 		
		 		: 모든 멤버변수는 public static final 이어야 한다. ==> 생략가능
		 		: 모든 메서드는 public abstract이여야 한다. ==> 생략가능
		 	- 인터페이스의 상속
		 		: 인터페이스는 인터페이스만 상속받을 수 있다.
		 		: 클래스와 달리 다중상속이 가능하다.
		 		: 인터페이스는 클래스와 달리 Object와 같은 최고 조상은 없다.
		 	- 인터페이스의 구현
		 		: 인터페이스는 객체 생성이 불가능하다.
		 		: 자신에 정의된 추상 메서드의 몸통을 만들어주는 클래스를 작성해야 한다.
		 		: 클래스의 상속(extends), 인터페이스의 구현(implements)
		 		: 인터페이스의 일부 메서드만 구현하였다면 그 클래스는 추상 클래스가 되어야 한다.
		 		: ~able(~을 할 수 있는) 필요한 메서드를 제공한다는 의미를 가지고 있다.
		 	- 인터페이스의 다형성	
		 		: 인터페이스 타입의 참조변수로 그를 구현한 구현체의 인스턴스를 참조할 수 있다. 	
		 	- 인터페이스의 장점
		 		: 개발시간을 단축 시킬 수 있다.
		 		: 표준화가 가능해 진다.
		 		: 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다. 
		 		: 독립적인 프로그래밍이 가능하다.
		 	- 인터페이스의 이해
		 		: 클래스를 사용하는 쪽(user)과 제공하는 쪽(provider)
		 		: 메서드를 사용하는 쪽에서는 메서드의 선언부만 알면 된다.
		 		: A - Interface - B : 인터페이스를 통한 간접적인 접근
		 		
		 		
		 19. 내부 클래스(Inner Class)
		 	- 내부클래스란?
		 		: 클래스내에 선언된 클래스이다.
		 		: 서로 쉽게 접근할 수 있고 외부에서 볼 때 불필요한 클래스를 감춤으로 복잡성을 줄일 수 있다.
		 	- 인스턴스클래스(Instance class)
		 		: 외부클래스의 인스턴스 멤버들과 관련된 작업을 수행한다.
		 	- 스태틱클래스(Static class)
		 		: 외부클래스의 클래스 멤버들과 관련된 작업을 수행한다.(클래스메서드)
		 	- 지역클래스(local class)
		 		: 외부클래스의 메서드 또는 초기화블럭안에 선언, 선언영역 내에서만 사용가능
		 	- 익명클래스(Anonymous class)
		 		: 클래스의 선언과 객체의 생성을 동시에 하는 이름 없는 클래스
		 */
	}
}